# figma换色插件

下面给你两份**V1 文档**（面向“完全不懂插件开发也能照着做”的程度），目标是做出**第一个可用版本**：

- 只处理**选中的 Frame（或任意容器节点）**内部所有图层
- 能**扫描色盘**（列出选区内出现的所有颜色：填充/描边/渐变 stops/阴影）
- 提供**饱和度**与**明度**滑杆（全局作用），一键应用到选区内所有可改颜色

---

# 文档 1：V1 开发计划与功能清单

## 1. 产品目标与边界

### 目标（V1 必须做到）

1. 用户选中一个 Frame（或 Group/Component 等容器）
2. 点击“扫描” → UI 展示一个“色盘列表”（颜色块 + 出现次数 + 来源类型）
3. 调整 **饱和度**、**明度**（全局）
4. 点击“应用” → 选区内所有可编辑的颜色统一按滑杆规则变化
5. UI 显示处理统计：处理节点数、修改项数、跳过项数、失败项数

### 不做（V1 明确不做，避免范围爆炸）

- 不做“逐色替换”（旧色 → 新色映射），只做全局 S/L 调整
- 不处理 Image/Video/Patterm Fill（这类不是颜色）
- 不做实时预览（拖动滑杆立即改画布），只在点击“应用”时执行
- 不做跨页面/整文件扫描（只针对当前选区根节点）

---

## 2. 功能清单（V1）

### A. 范围与选择

- **只处理当前选中**的一个节点作为根（推荐 Frame）
- 若未选中：提示“请先选中一个 Frame/容器”
- 若选中多个：提示“请只选中一个根节点”（或默认取第一个）

**验收标准**

- 未选中/多选时不会误改画布，并且 UI 给出明确提示

---

### B. 颜色覆盖范围（必须支持）

1. **Fill（填充）**
- Solid：修改其 `color`
- Gradient：修改每个 `gradientStop.color`
- 其它：跳过（Image/Video 等）
1. **Stroke（描边）**
- 同 Fill（Paint 列表）
1. **Effect（效果）**
- 只处理 `DROP_SHADOW` / `INNER_SHADOW` 的 `color`
- 其它 effect（Blur）跳过

**验收标准**

- 复杂 Frame 中：纯色、渐变、阴影颜色都会跟着变化

---

### C. 色盘（扫描结果展示）

扫描后 UI 展示一个列表（按出现次数降序）：

- 颜色 swatch（小色块）
- RGBA（或 Hex，建议 UI 显示 Hex 方便对照）
- 出现次数 count
- 来源 tags（fill / stroke / gradient-stop / shadow）

**验收标准**

- 扫描后，UI 能看到“这个选区里到底用了哪些颜色，哪些用得最多”

---

### D. 饱和度 & 明度（全局调整）

- 饱和度 S：范围 `100% ~ +100%`
- 明度 L：范围 `100% ~ +100%`
- 算法：对每个颜色做 RGBA → HSL → 调整 S/L → HSL → RGBA（并 clamp 到 0~1）

**验收标准**

- S 增加会更鲜艳、S 减少会更灰
- L 增加会更亮、L 减少会更暗
- 不出现颜色溢出（<0 或 >1）

---

### E. 统计与可观测性（强烈建议 V1 就做）

应用完成后在 UI 显示：

- visitedNodes：遍历了多少节点
- modifiedPaints：修改了多少个 paint（含渐变 stops）
- modifiedEffects：修改了多少阴影
- skipped：跳过了多少项（image fill、mixed、无权限等）
- failed：try/catch 捕获的失败次数（实例受限等）

**验收标准**

- 当用户说“怎么没改掉某些颜色”，你能从统计看出是 skip 还是 fail

---

## 3. 开发任务清单（一步步执行）

> 下面按“做完一个就能验证一个”的顺序排，适合新手。
> 

### Step 0：创建工程骨架

- 在 Figma Desktop：Plugins → Development → New plugin
- 选择 **Custom UI**
- 选择 TypeScript（如果有选项）
- 确认能运行，弹出一个空 UI

**完成定义**

- 插件能在 Figma 里运行并显示 UI 窗口

---

### Step 1：搭好 UI ↔ Main 通信

- UI 点击按钮发送消息：`SCAN_REQUEST`、`APPLY_REQUEST`
- Main 回消息：`SCAN_RESULT`、`APPLY_RESULT`、`ERROR`、`PROGRESS`

**完成定义**

- UI 点击“扫描”后，Main 能收到并回一句 “ok” 显示在 UI 上

---

### Step 2：实现选区根节点获取 + 遍历器

- Main：读取 `figma.currentPage.selection`
- 校验：0 个/多个 → 返回错误
- 写一个 `collectDescendants(root)` 返回所有后代节点（含 root 可选）

**完成定义**

- UI 能显示 “遍历节点数：xxx”

---

### Step 3：实现“颜色扫描器”（只读）

对每个节点尝试读取：

- fills（Paint[]）
- strokes（Paint[]）
- effects（Effect[]）

扫描过程中：

- 把收集到的颜色标准化成 ColorKey（例如 0~255 整数形式的 `r,g,b,a`）
- 聚合统计（出现次数、来源 tags）

**完成定义**

- UI 能展示色盘列表（至少 10 条颜色也不乱）

---

### Step 4：实现 Color Engine（HSL 调整）

- 写纯函数：`adjustColorRGBA(rgba, satDelta, lightDelta) -> rgba`
- satDelta/lightDelta 由 UI 滑杆传入（-1~+1 或 -100~+100）

**完成定义**

- 给定一个颜色输入能输出合理的调整结果（可用 console/log 对比）

---

### Step 5：实现“应用器”（写回 fills/strokes/effects）

- 再遍历一次节点（或扫描时记录引用，但新手建议再遍历一次更简单）
- 对每个 paint：
    - Solid：改 color
    - Gradient：遍历 stops 改 stop.color
    - 其它跳过
- 对阴影 effect：改 color
- 每处理 N 个节点，向 UI 发一次 PROGRESS

**完成定义**

- 点“应用”后画布可见变化，且统计数据合理

---

### Step 6：容错与用户体验收尾

- 处理 `mixed` 值：跳过并计入 skipped
- try/catch 包裹写操作：失败计入 failed
- UI：把错误用醒目方式显示

**完成定义**

- 复杂文件里不会“直接崩”，失败可被统计和提示

---

## 4. V1 测试清单（你照着造一个测试文件）

1. Frame 内只有纯色矩形（fill）
2. 有描边（stroke）
3. 有线性渐变（2~3 stops）
4. 有 drop shadow / inner shadow
5. 同一个颜色重复出现很多次（验证 count 排序）
6. 混合选区/锁定层/组件实例（验证 skip/fail 统计）

---

---

# 文档 2：V1 插件架构文档

## 1. 目录结构（推荐）

（用 TypeScript + 原生 UI 最省心）

```
/src
  main.ts                 // 插件逻辑入口（无 DOM）
  ui.html                 // UI 容器
  ui.ts                   // UI 逻辑（DOM/事件/渲染）
  color/
    color-model.ts        // RGBA/HS(L) 类型、转换、clamp
    color-adjust.ts       // 饱和度/明度调整
  figma/
    traverse.ts           // 遍历选区树
    scan.ts               // 扫描 fills/strokes/effects → palette
    apply.ts              // 按 sat/light 写回
  shared/
    types.ts              // 消息协议、数据结构
    color-key.ts          // ColorKey 规范化、hex 输出
/manifest.json

```

> 你未来要加“逐色替换”“预设保存”“只改某类颜色”等，都能自然扩展在 scan/apply 和 UI。
> 

---

## 2. 模块职责

### Main 进程（main.ts）

**职责**

- 读取选区根节点
- 遍历节点树
- 调用 scan/apply
- 与 UI 通信（postMessage / onmessage）
- 负责统计与错误处理

**不应该做**

- 不做复杂 UI 字符串拼接
- 不写颜色转换算法（放 color/）

---

### UI（ui.ts + ui.html）

**职责**

- 渲染色盘列表
- 管理滑杆状态（sat/light）
- 按钮：扫描/应用
- 显示进度与统计
- 显示错误消息

**不应该做**

- 不直接调用 figma API（只能通过 postMessage 让 main 做）

---

### 扫描器（scan.ts）

**输入**

- rootNode（选中的根节点）
- options（是否包含 fills/strokes/effects/gradientStops 等）

**输出**

- palette：唯一颜色集合 + 统计信息
- metrics：遍历数量、跳过数量等

---

### 应用器（apply.ts）

**输入**

- rootNode
- satDelta, lightDelta
- options（哪些来源参与调整）

**输出**

- metrics（修改数、失败数、跳过数、耗时可选）

---

### Color Engine（color-model.ts / color-adjust.ts）

**输入**

- RGBA (0~1)
- sat/light 调整量

**输出**

- 调整后的 RGBA（仍是 0~1 且 clamp）

---

## 3. 数据结构设计

### 3.1 颜色表示

```tsx
type RGBA01 = { r: number; g: number; b: number; a: number }; // 0..1
type ColorKey = string; // 例如 "255,128,0,255"

```

**ColorKey 规则（建议）**

- 把 rgba(0..1) 乘 255 四舍五入成整数
- 拼成字符串：`r,g,b,a`
- 用于去重、计数、排序

---

### 3.2 色盘项

```tsx
type PaletteItem = {
  key: ColorKey;
  rgba: RGBA01;            // 用于渲染 swatch
  hex: string;             // UI 展示（可选）
  count: number;           // 出现次数
  sources: Array<"fill" | "stroke" | "gradient-stop" | "shadow">;
};

```

---

### 3.3 消息协议（UI ↔ Main）

```tsx
// UI -> Main
type ScanRequest = { type: "SCAN_REQUEST"; options: ScanOptions };
type ApplyRequest = {
  type: "APPLY_REQUEST";
  options: ApplyOptions;
  satDelta: number;   // -1..+1 或 -100..+100（统一一种）
  lightDelta: number;
};

// Main -> UI
type ScanResult = { type: "SCAN_RESULT"; palette: PaletteItem[]; metrics: Metrics };
type ApplyResult = { type: "APPLY_RESULT"; metrics: Metrics };
type Progress = { type: "PROGRESS"; processed: number; total: number };
type ErrorMsg = { type: "ERROR"; message: string };

```

---

## 4. 核心算法与处理规则

### 4.1 遍历策略

- 使用 DFS/BFS 遍历 `root.children`（递归或栈）
- 对每个节点：
    - 如果节点类型不支持 fills/strokes/effects → 跳过（但仍计入 visited）
    - 如果 fills/strokes 是 mixed → skip（计数 +1）

> V1 选择“遇到 mixed 就跳过”是最稳妥的；后续版本再做细粒度处理。
> 

---

### 4.2 Paint 处理规则

- `SOLID`：调整 paint.color（保留 alpha）
- `GRADIENT_*`：遍历 gradientStops，调整 stop.color
- 其他 paint 类型：跳过

---

### 4.3 Effect 处理规则

- 仅处理 shadow 类 effect 的 color
- 其他 effect 不动

---

### 4.4 S/L 调整规则（推荐简单直观）

- `S = clamp(S + satDelta)`
- `L = clamp(L + lightDelta)`

或者用比例乘法（更“摄影调色”）：

- `S = clamp(S * (1 + satDelta))`
- `L = clamp(L * (1 + lightDelta))`

V1 建议选“加法”更符合用户预期（-50% 就是更灰一半的方向），并且更好控。

---

## 5. 性能与稳定性策略（V1 就要考虑）

- 大 Frame 会有很多节点：每处理固定数量（如 50/100 个）给 UI 发一次 PROGRESS
- 所有写操作 try/catch
- 统计“跳过/失败”是 V1 稳定性的核心

---

## 6. V1 的“完成定义”（Definition of Done）

当满足以下条件，就算 V1 合格：

1. 选中一个复杂 Frame → 扫描能出色盘列表
2. 明度/饱和度调整后点击应用：
    - 纯色 fill/stroke/阴影会变
    - 渐变 stops 会变
3. UI 能显示处理统计与错误提示
4. 遇到不支持或 mixed 不崩溃，只会 skip 并统计

---

如果你愿意，我下一条消息可以直接把**V1 可运行的工程骨架**（`manifest.json + main.ts + ui.html + ui.ts + color engine + scan/apply 模块`）完整输出给你，你只要复制进文件夹、build、在 Figma 里导入开发插件就能跑。你只需要告诉我你希望用的构建方式：

- A）最简单：原生 + 轻量 bundler（推荐）
- B）React + Vite（UI 更舒服，但新手步骤更长）